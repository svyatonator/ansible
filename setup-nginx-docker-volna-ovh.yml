- name: Setup Docker nginx static sites (volna.ovh domains)
  hosts: servers
  gather_facts: true
  become: true

  vars:
    nginx_docker_root: /opt/nginx-docker
    nginx_container_name: nginx
    letsencrypt_webroot: /var/www/letsencrypt
    certbot_email: ""
    certbot_cert_name: volna.ovh
    certbot_domains:
      - volna.ovh
      - kit.volna.ovh
      - port.volna.ovh
    sites:
      - domain: volna.ovh
      - domain: kit.volna.ovh
      - domain: port.volna.ovh
    compose_plugin_version: v2.33.1
    compose_arch_map:
      x86_64: x86_64
      amd64: x86_64
      aarch64: aarch64
      arm64: aarch64

  tasks:
    - name: Install Docker and certbot
      ansible.builtin.apt:
        name:
          - docker.io
          - certbot
          - openssl
        state: present
        update_cache: true

    - name: Try to install Docker Compose plugin package
      ansible.builtin.apt:
        name: docker-compose-plugin
        state: present
      register: compose_plugin_install
      failed_when: false

    - name: Install legacy docker-compose package when plugin is unavailable
      ansible.builtin.apt:
        name: docker-compose
        state: present
      when: compose_plugin_install.rc is defined and compose_plugin_install.rc != 0

    - name: Ensure Docker is enabled and started
      ansible.builtin.service:
        name: docker
        enabled: true
        state: started

    - name: Detect Docker Compose v2 command
      ansible.builtin.shell: |
        if docker compose version >/dev/null 2>&1; then
          echo "docker compose"
        else
          exit 1
        fi
      register: docker_compose_detect
      changed_when: false
      failed_when: false

    - name: Ensure Docker CLI plugins directory exists
      ansible.builtin.file:
        path: /usr/local/lib/docker/cli-plugins
        state: directory
        owner: root
        group: root
        mode: "0755"
      when: docker_compose_detect.rc != 0

    - name: Install Docker Compose v2 CLI plugin binary fallback
      ansible.builtin.get_url:
        url: "https://github.com/docker/compose/releases/download/{{ compose_plugin_version }}/docker-compose-linux-{{ compose_arch_map.get(ansible_facts['architecture'], 'x86_64') }}"
        dest: /usr/local/lib/docker/cli-plugins/docker-compose
        owner: root
        group: root
        mode: "0755"
      when: docker_compose_detect.rc != 0

    - name: Re-detect Docker Compose v2 command after plugin fallback
      ansible.builtin.shell: |
        if docker compose version >/dev/null 2>&1; then
          echo "docker compose"
        else
          exit 1
        fi
      register: docker_compose_detect_retry
      changed_when: false
      failed_when: false
      when: docker_compose_detect.rc != 0

    - name: Choose effective Docker Compose detection result
      ansible.builtin.set_fact:
        docker_compose_detect_effective: "{{ docker_compose_detect_retry if docker_compose_detect.rc != 0 else docker_compose_detect }}"

    - name: Fail if Docker Compose is still unavailable
      ansible.builtin.fail:
        msg: "Neither 'docker compose' nor 'docker-compose' is available after fallback installation."
      when: docker_compose_detect_effective.rc != 0

    - name: Set Docker Compose command fact
      ansible.builtin.set_fact:
        docker_compose_cmd: "{{ docker_compose_detect_effective.stdout }}"

    - name: Allow HTTP traffic through UFW (if UFW is active)
      ansible.builtin.ufw:
        rule: allow
        port: "80"
        proto: tcp
      ignore_errors: true

    - name: Allow HTTPS traffic through UFW (if UFW is active)
      ansible.builtin.ufw:
        rule: allow
        port: "443"
        proto: tcp
      ignore_errors: true

    - name: Ensure webroot for ACME challenge exists
      ansible.builtin.file:
        path: "{{ letsencrypt_webroot }}"
        state: directory
        owner: root
        group: root
        mode: "0755"

    - name: Ensure letsencrypt directory exists
      ansible.builtin.file:
        path: /etc/letsencrypt
        state: directory
        owner: root
        group: root
        mode: "0755"

    - name: Install nginx TLS options file for certbot-compatible config
      ansible.builtin.copy:
        dest: /etc/letsencrypt/options-ssl-nginx.conf
        owner: root
        group: root
        mode: "0644"
        content: |
          ssl_session_cache shared:le_nginx_SSL:10m;
          ssl_session_timeout 1440m;
          ssl_session_tickets off;
          ssl_protocols TLSv1.2 TLSv1.3;
          ssl_prefer_server_ciphers off;
          ssl_ciphers "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384";

    - name: Generate dhparams file for nginx TLS if missing
      ansible.builtin.command:
        cmd: openssl dhparam -out /etc/letsencrypt/ssl-dhparams.pem 2048
        creates: /etc/letsencrypt/ssl-dhparams.pem

    - name: Ensure static site directories exist
      ansible.builtin.file:
        path: "/var/www/{{ item.domain }}"
        state: directory
        owner: root
        group: root
        mode: "0755"
      loop: "{{ sites }}"

    - name: Create placeholder index.html for each site
      ansible.builtin.copy:
        dest: "/var/www/{{ item.domain }}/index.html"
        content: "<h1>{{ item.domain }} via Docker nginx</h1>\n"
        owner: root
        group: root
        mode: "0644"
        force: false
      loop: "{{ sites }}"

    - name: Create Docker nginx project directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: "0755"
      loop:
        - "{{ nginx_docker_root }}"
        - "{{ nginx_docker_root }}/conf.d"

    - name: Check if certificate already exists
      ansible.builtin.stat:
        path: "/etc/letsencrypt/live/{{ certbot_cert_name }}/fullchain.pem"
      register: certbot_existing_cert

    - name: Set TLS mode for nginx config
      ansible.builtin.set_fact:
        nginx_enable_tls: "{{ certbot_existing_cert.stat.exists | bool }}"

    - name: Write nginx main config
      ansible.builtin.template:
        src: templates/nginx-docker-nginx.conf.j2
        dest: "{{ nginx_docker_root }}/nginx.conf"
        owner: root
        group: root
        mode: "0644"
      notify: Restart nginx docker stack

    - name: Write nginx domain config
      ansible.builtin.template:
        src: templates/nginx-docker-volna-sites.conf.j2
        dest: "{{ nginx_docker_root }}/conf.d/volna-sites.conf"
        owner: root
        group: root
        mode: "0644"
      notify: Restart nginx docker stack

    - name: Write docker compose file for nginx
      ansible.builtin.template:
        src: templates/docker-compose-nginx-volna.yml.j2
        dest: "{{ nginx_docker_root }}/docker-compose.yml"
        owner: root
        group: root
        mode: "0644"
      notify: Restart nginx docker stack

    - name: Stop and disable host nginx to free ports 80/443
      ansible.builtin.service:
        name: nginx
        state: stopped
        enabled: false
      failed_when: false

    - name: Ensure nginx docker stack is up
      ansible.builtin.command:
        cmd: "{{ docker_compose_cmd }} up -d"
        chdir: "{{ nginx_docker_root }}"

    - name: Flush handlers to apply any config changes
      ansible.builtin.meta: flush_handlers

    - name: Validate nginx config inside container
      ansible.builtin.command:
        cmd: docker exec {{ nginx_container_name }} nginx -t
      register: nginx_test
      changed_when: false

    - name: Print nginx config test output
      ansible.builtin.debug:
        msg: "{{ nginx_test.stderr_lines }}"

    - name: Require certbot_email for first certificate issuance
      ansible.builtin.fail:
        msg: "First certificate issuance requires contact email. Run with -e certbot_email=admin@volna.ovh"
      when:
        - not certbot_existing_cert.stat.exists
        - certbot_email | length == 0

    - name: Issue initial certificate with webroot when missing
      ansible.builtin.command:
        argv:
          - certbot
          - certonly
          - --webroot
          - -w
          - "{{ letsencrypt_webroot }}"
          - -d
          - "{{ certbot_domains[0] }}"
          - -d
          - "{{ certbot_domains[1] }}"
          - -d
          - "{{ certbot_domains[2] }}"
          - --cert-name
          - "{{ certbot_cert_name }}"
          - --email
          - "{{ certbot_email }}"
          - --agree-tos
          - --non-interactive
      register: certbot_initial_issue
      changed_when: true
      when: not certbot_existing_cert.stat.exists

    - name: Print initial certbot issue result
      ansible.builtin.debug:
        msg: "{{ certbot_initial_issue.stdout_lines }}"
      when: certbot_initial_issue is defined and not certbot_initial_issue.skipped

    - name: Enable TLS mode after initial certificate issuance
      ansible.builtin.set_fact:
        nginx_enable_tls: true
      when: certbot_initial_issue is defined and not certbot_initial_issue.skipped

    - name: Rewrite nginx domain config with TLS after initial certificate issuance
      ansible.builtin.template:
        src: templates/nginx-docker-volna-sites.conf.j2
        dest: "{{ nginx_docker_root }}/conf.d/volna-sites.conf"
        owner: root
        group: root
        mode: "0644"
      notify: Restart nginx docker stack
      when: certbot_initial_issue is defined and not certbot_initial_issue.skipped

    - name: Apply nginx TLS config after initial certificate issuance
      ansible.builtin.meta: flush_handlers
      when: certbot_initial_issue is defined and not certbot_initial_issue.skipped

    - name: Validate nginx config inside container after enabling TLS
      ansible.builtin.command:
        cmd: docker exec {{ nginx_container_name }} nginx -t
      register: nginx_test_tls
      changed_when: false
      when: certbot_initial_issue is defined and not certbot_initial_issue.skipped

    - name: Print nginx TLS config test output
      ansible.builtin.debug:
        msg: "{{ nginx_test_tls.stderr_lines }}"
      when: certbot_initial_issue is defined and not certbot_initial_issue.skipped

    - name: Ensure certbot deploy hook directory exists
      ansible.builtin.file:
        path: /etc/letsencrypt/renewal-hooks/deploy
        state: directory
        owner: root
        group: root
        mode: "0755"

    - name: Install deploy hook to reload docker nginx after renew
      ansible.builtin.copy:
        dest: /etc/letsencrypt/renewal-hooks/deploy/reload-nginx-docker.sh
        owner: root
        group: root
        mode: "0755"
        content: |
          #!/bin/sh
          if docker ps --format '{{ "{{" }}.Names{{ "}}" }}' | grep -qx '{{ nginx_container_name }}'; then
            docker exec {{ nginx_container_name }} nginx -s reload >/dev/null 2>&1 || true
          fi
          exit 0

    - name: Check renewal config exists
      ansible.builtin.stat:
        path: "/etc/letsencrypt/renewal/{{ certbot_cert_name }}.conf"
      register: certbot_renewal_conf

    - name: Force renewal config to use webroot authenticator
      ansible.builtin.ini_file:
        path: "/etc/letsencrypt/renewal/{{ certbot_cert_name }}.conf"
        section: renewalparams
        option: authenticator
        value: webroot
        mode: "0644"
      when: certbot_renewal_conf.stat.exists

    - name: Remove nginx installer from renewal config
      ansible.builtin.ini_file:
        path: "/etc/letsencrypt/renewal/{{ certbot_cert_name }}.conf"
        section: renewalparams
        option: installer
        state: absent
        mode: "0644"
      when: certbot_renewal_conf.stat.exists

    - name: Set webroot path in renewal config
      ansible.builtin.ini_file:
        path: "/etc/letsencrypt/renewal/{{ certbot_cert_name }}.conf"
        section: renewalparams
        option: webroot_path
        value: "{{ letsencrypt_webroot }}"
        mode: "0644"
      when: certbot_renewal_conf.stat.exists

    - name: Re-issue certificate once with webroot to finalize migration
      ansible.builtin.command:
        argv:
          - certbot
          - certonly
          - --webroot
          - -w
          - "{{ letsencrypt_webroot }}"
          - -d
          - "{{ certbot_domains[0] }}"
          - -d
          - "{{ certbot_domains[1] }}"
          - -d
          - "{{ certbot_domains[2] }}"
          - --cert-name
          - "{{ certbot_cert_name }}"
          - --force-renewal
          - --non-interactive
      register: certbot_config
      changed_when: true
      when:
        - certbot_renewal_conf.stat.exists
        - certbot_existing_cert.stat.exists

    - name: Print certbot reconfigure result
      ansible.builtin.debug:
        msg: "{{ certbot_config.stdout_lines }}"

    - name: Validate certbot automatic renewal
      ansible.builtin.command:
        cmd: certbot renew --dry-run
      register: certbot_dry_run
      changed_when: false

    - name: Print certbot dry-run result
      ansible.builtin.debug:
        msg: "{{ certbot_dry_run.stdout_lines }}"

  handlers:
    - name: Restart nginx docker stack
      ansible.builtin.command:
        cmd: "{{ docker_compose_cmd }} up -d"
        chdir: "{{ nginx_docker_root }}"
